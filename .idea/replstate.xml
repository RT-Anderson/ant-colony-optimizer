<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449663071724">{:repl-history {:ide [], :local [&quot;(map #(repeat (- cnt 1 %) %) '(0 1 2 3))&quot; &quot;(flatten (mapv #(repeat (- cnt 1 %) %) '(0 1 2 3)))&quot; &quot;(flattenv (mapv #(repeat (- cnt 1 %) %) '(0 1 2 3)))&quot; &quot;(flatten (map #(repeat (- cnt 1 %) %) '(0 1 2 3)))&quot; &quot;(map  #(range (+ % 1) cnt) '(0 1 2 3))&quot; &quot;(flatten(map  #(range (+ % 1) cnt) '(0 1 2 3)))&quot; &quot;(range 4)&quot; &quot;(defn create-keys2\n  [waypt-cnt]\n  (let [nodesA (flatten (map #(repeat (- waypt-cnt 1 %) %) (range waypt-cnt)))\n        nodesB (flatten (map #(repeat (- waypt-cnt 1 %) %) (range waypt-cnt)))]\n    nodesB))&quot; &quot;(defn create-keys2\n  [waypt-cnt]\n  (let [nodesA (flatten (map #(repeat (- waypt-cnt 1 %) %) (range waypt-cnt)))\n        nodesB (flatten(map  #(range (+ % 1) waypt-cnt) (range waypt-cnt)))]\n    nodesB))&quot; &quot;(defn create-keys2\n  [waypt-cnt]\n  (let [nodesA (flatten (map #(repeat (- waypt-cnt 1 %) %) (range waypt-cnt)))\n        nodesB (flatten(map  #(range (+ % 1) waypt-cnt) (range waypt-cnt)))]\n    (mapv #(get-edge %1 %2) nodesA nodesB)))&quot; &quot;(create-keys2 3)&quot; &quot;(create-keys2 4)&quot; &quot;(create-keys2 5)&quot; &quot;(defn create-keys2\n  [waypoint-cnt]\n  (let [nodesA (flatten (map #(repeat (- waypoint-cnt 1 %) %) (range waypoint-cnt)))\n        nodesB (flatten(map  #(range (+ % 1) waypoint-cnt) (range waypoint-cnt)))]\n    (mapv #(get-edge %1 %2) nodesA nodesB)))&quot; &quot;(defn create-keys\n  [waypoint-cnt]\n  (let [nodesA (flatten (map #(repeat (- waypoint-cnt 1 %) %) (range waypoint-cnt)))\n        nodesB (flatten(map  #(range (+ % 1) waypoint-cnt) (range waypoint-cnt)))]\n    (mapv #(get-edge %1 %2) nodesA nodesB)))&quot; &quot;(def k (create-keys 3))&quot; &quot;(zipmap k (repeat 0))&quot; &quot;(def colony\n  {:alpha-coeff 1\n   :beta-coeff  1.5\n   :tour-coeff  1\n   :waypoints   '([16 6] [11 5] [12 5] [2 12])\n   :pher-map    (atom {:01 1 :02 1 :03 1\n                 :12 1 :13 1\n                 :23 1})\n   :pher-update (atom {:01 0 :02 0 :03 0\n                 :12 0 :13 0\n                 :23 0})\n   :tour-count  5\n   :ant-count   3\n   :best-route (atom {:score 0 :path []})})&quot; &quot;(defn create-colony\n  [waypoint-cnt tours ants]\n  {:alpha-coeff 1\n   :beta-coeff 1.2\n   :tour-coeff 1\n   :waypoints (t/set-waypoints waypoint-cnt 20)\n   :pher-map (atom (zipmap (t/create-keys waypoint-cnt) (repeat 1)))\n   :pher-update (atom (zipmap (t/create-keys waypoint-cnt) (repeat 0)))\n   :tour-count tours\n   :ant-count ants\n   :best-route (atom {:score 0 :path []})})&quot; &quot;(def colony1 \n  (create-colony 4 3 10))&quot; &quot;colony1&quot; &quot;(defn create-colony\n  [waypoint-cnt tours ants]\n  {:alpha-coeff 1\n   :beta-coeff 1.2\n   :tour-coeff 1\n   :waypoints (t/set-waypoints waypoint-cnt 20)\n   :pher-map (atom (zipmap (t/create-keys waypoint-cnt) (repeat 1)))\n   :pher-update (atom (zipmap (t/create-keys waypoint-cnt) (repeat 0)))\n   :pher-reset (atom (zipmap (t/create-keys waypoint-cnt) (repeat 0)))\n   :tour-count tours\n   :ant-count ants\n   :best-route (atom {:score 0 :path []})})&quot; &quot;(defn create-colony\n  [waypoint-cnt tours ants evap-rate]\n  {:alpha-coeff 1\n   :beta-coeff 1.2\n   :tour-coeff 1\n   :waypoints (t/set-waypoints waypoint-cnt 20)\n   :pher-map (atom (zipmap (t/create-keys waypoint-cnt) (repeat 1)))\n   :pher-update (atom (zipmap (t/create-keys waypoint-cnt) (repeat 0)))\n   :pher-reset (zipmap (t/create-keys waypoint-cnt) (repeat 0))\n   :evap (zipmap (t/create-keys waypoint-cnt) (repeat (- 1 evap-rate)))\n   :tour-count tours\n   :ant-count ants\n   :best-route (atom {:score 0 :path []})})&quot; &quot;(defn execute\n  [tour-count ant-count colony]\n  (loop [counter (dec tour-count)]\n    (colony-tour ant-count colony)\n    (if (zero? counter)\n      (doall\n        (println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        (println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony))))\n      (recur (dec counter)))))&quot; &quot;(def colony1 create-colony 4 3 5 0.2 )&quot; &quot;(def colony1 \n  (create-colony 4 3 5 0.2 ))&quot; &quot;(defn execute\n  [tour-count ant-count colony]\n  (loop [counter (dec tour-count)]\n    (colony-tour ant-count colony)\n    (if (zero? counter)\n      (doall\n        (println \&quot;Results\&quot;)\n        ;;(println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        ;;(println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony)))\n        )\n      (recur (dec counter)))))&quot; &quot;(defn execute\n  [tour-count ant-count colony]\n  (loop [counter (dec tour-count)]\n    ;;(colony-tour ant-count colony)\n    (if (zero? counter)\n      (doall\n        (println \&quot;Results\&quot;)\n        ;;(println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        ;;(println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony)))\n        )\n      (recur (dec counter)))))&quot; &quot;(defn execute\n  [tour-count ant-count colony]\n  (loop [counter (dec tour-count)]\n    ;;(colony-tour ant-count colony)\n    (if (zero? counter)\n      (doall\n        (println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        (println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony))))\n      (recur (dec counter)))))&quot; &quot;(defn colony-tour\n  ;; Ant tours not being called in parallel --TO FIX\n  ;; Has N number of ants complete a full route and update the pheremone value\n  [ant-count colony]\n  (reset! ant-counter 0)\n  (loop [counter (dec ant-count)]\n    (ant colony)\n    (if (zero? counter)\n      (reset! (:pher-map colony) (merge-with + @(:evap colony) @(:pher-update colony) @(:pher-map colony)))\n      (recur (dec counter))))\n  ;;@ant-counter\n  )&quot; &quot;(defn get-route-distance\n  [path colony]\n  (if (empty? path) \n    nil\n  (let [path2 (conj (subvec path 1) (first path))]\n    (reduce + (map #(get-distance %1 %2 (:waypoints colony)) path path2)))))&quot; &quot;(defn colony-tour\n  ;; Ant tours not being called in parallel --TO FIX\n  ;; Has N number of ants complete a full route and update the pheremone value\n  [ant-count colony]\n  (reset! ant-counter 0)\n  (loop [counter (dec ant-count)]\n    (println \&quot;AA\&quot;)\n    (ant colony)\n\n    (if (zero? counter)\n      (println \&quot;WWW\&quot;)\n      (reset! (:pher-map colony) (merge-with + @(:evap colony) @(:pher-update colony) @(:pher-map colony)))\n      (recur (dec counter))))\n  @ant-counter)&quot; &quot;(reset! (:pher-map colony1) 1)&quot; &quot;(reset! (:pher-map colony1)\n        (merge-with + \n                    (:evap colony1) \n                    @(:pher-update colony1) \n                    @(:pher-map colony1)))&quot; &quot;(defn execute\n  [tour-count ant-count colony]\n  (loop [counter (dec tour-count)]\n    (colony-tour ant-count colony)\n    (if (zero? counter)\n      (doall\n        (println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        (println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony)))\n        )\n      (recur (dec counter)))))&quot; &quot;@(:pher-map colony1)&quot; &quot;@(:best-route colony)&quot; &quot;(defn execute\n  [tour-count ant-count colony]\n  (loop [counter (dec tour-count)]\n    (println (str counter))\n    (colony-tour ant-count colony)\n    (if (zero? counter)\n      \n      (doall\n        (println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        (println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony)))\n        )\n      (recur (dec counter)))))&quot; &quot;(reset! (:pher-map colony1)\n        (merge-with +\n                    (:evap colony1)\n                    @(:pher-update colony1)\n                    @(:pher-map colony1)))&quot; &quot;(:evap colony1)&quot; &quot;(def co1 (create-colony 5 2 2 .2))&quot; &quot;(update-colony co1)&quot; &quot;(defn colony-tour\n  ;; Ant tours not being called in parallel --TO FIX\n  ;; Has N number of ants complete a full route and update the pheremone value\n  [ant-count colony]\n  (reset! ant-counter 0)\n  (loop [counter (dec ant-count)]\n    (ant colony)\n\n    (if (zero? counter)\n      (doall\n        (println (str @(:pher-map colony)))\n        (reset! (:pher-map colony) (merge-with + (:evap colony) @(:pher-update colony)))\n        )\n      (recur (dec counter))))\n  @ant-counter)&quot; &quot;(defn colony-tour\n  ;; Ant tours not being called in parallel --TO FIX\n  ;; Has N number of ants complete a full route and update the pheremone value\n  [ant-count colony]\n  (reset! ant-counter 0)\n  (loop [counter (dec ant-count)]\n    (ant colony)\n\n    (if (zero? counter)\n      (do\n        (println (str @(:pher-map colony)))\n        (println (str (:evap colony)))\n        (println (str @(:pher-update colony)))\n        (reset! (:pher-map colony) (merge-with + (:evap colony) @(:pher-update colony)))\n        )\n      (recur (dec counter))))\n  @ant-counter)&quot; &quot;(def co1 (create-colony 5 2 2 0.2))&quot; &quot;(defn update-colony\n  [colo]\n  (reset! (:pher-map colo) 1))&quot; &quot;(execute 10 10 colony1)&quot; &quot;@ant-counter&quot; &quot;@(:pher-map colony)&quot; &quot;@(:pher-update colony)&quot; &quot;(defn evaluate-route\n  ;; The best route is compared to every route taken &amp; updated when a better one is found\n  [path score best-route]\n  (if (&gt; score (:score @best-route)))\n    (let [better-route {:score score :path path}]\n      (reset! best-route better-route)))&quot; &quot;(defn evaluate-route\n  ;; The best route is compared to every route taken &amp; updated when a better one is found\n  [path score best-route]\n  (if (&gt; score (:score @best-route))\n    (let [better-route {:score score :path path}]\n      (reset! best-route better-route))))&quot; &quot;(defn execute\n  [colony]\n  (loop [counter (dec (:tour-count colony))]\n    (colony-tour (:ant-count colony) colony)\n    (if (zero? counter)\n      (doall\n        (println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        (println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony))))\n      (recur (dec counter)))))&quot; &quot;(def colony1\n  (create-colony 4 3 5 0.2 ))&quot; &quot;(execute colony1)&quot; &quot;(def colony1\n  (create-colony 50 3 5 0.2 ))&quot; &quot;(defn create-colony\n  [waypoint-list tours ants evap-rate]\n  {:alpha-coeff 1\n   :beta-coeff 1.2\n   :tour-coeff 1\n   :waypoints (t/set-waypoints (count waypoint-list) 20)\n   :pher-map (atom (zipmap (t/create-keys (count waypoint-list)) (repeat 1)))\n   :pher-update (atom (zipmap (t/create-keys (count waypoint-list)) (repeat 0)))\n   :pher-reset (zipmap (t/create-keys (count waypoint-list)) (repeat 0))\n   :evap (zipmap (t/create-keys (count waypoint-list)) (repeat (- 1 evap-rate)))\n   :tour-count tours\n   :ant-count ants\n   :best-route (atom {:score 0 :path []})})&quot; &quot;(def colony\n  (aco/create-colony waypoints 3 20 0.3))&quot; &quot;(def colony\n  (aco/create-colony waypoints 3 50 0.3))&quot; &quot;(defn create-colony\n  [waypoint-list tours ants evap-rate]\n  {:alpha-coeff 1\n   :beta-coeff 1.2\n   :tour-coeff 1\n   :waypoints (t/set-waypoints (count waypoint-list) 20)\n   :pher-map (atom (zipmap (t/create-keys (count waypoint-list)) (repeat 1)))\n   :pher-update (atom (zipmap (t/create-keys (count waypoint-list)) (repeat 0)))\n   :pher-reset (zipmap (t/create-keys (count waypoint-list)) (repeat 1))\n   :pher-update-reset (zipmap (t/create-keys (count waypoint-list)) (repeat 1))\n   :evap (zipmap (t/create-keys (count waypoint-list)) (repeat (- 1 evap-rate)))\n   :tour-count tours\n   :ant-count ants\n   :best-route (atom {:score 0 :path []})})&quot; &quot;(defn execute\n  [colony]\n  (loop [counter (dec (:tour-count colony))]\n    (colony-tour (:ant-count colony) colony)\n    (if (zero? counter)\n      (do\n        (println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        (println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony)))\n        (reset! (:pher-map colony) (:pher-reset colony)))\n      (recur (dec counter)))))&quot; &quot;(def waypoints\n  (t/set-waypoints 4 20))&quot; &quot;(def colony\n  (aco/create-colony waypoints 5 50 0.3))&quot; &quot;(defn evaluate-route\n  ;; The best route is compared to every route taken &amp; updated when a better one is found\n  [path score best-route waypoints]\n  (if (&gt; score (:score @best-route))\n    (let [better-route {:score score :path path}]\n      (println \&quot;Shortest path found: \&quot; (str path)))\n      (println \&quot;Path distance: \&quot; (str (get-route-distance path waypoints)))\n      (reset! best-route better-route)))&quot; &quot;(defn colony-tour\n  ;; Ant tours not being called in parallel --TO FIX\n  ;; Has N number of ants complete a full route and update the pheremone value\n  [ant-count colony]\n  (reset! ant-counter 0)\n  (loop [counter (dec ant-count)]\n    (ant colony)\n\n    (if (zero? counter)\n      (do\n        (reset! (:pher-map colony) (merge-with + (:evap colony) @(:pher-update colony) @(:pher-map colony)))\n        (reset! (:pher-update colony) (:pher-update-reset colony))\n        )\n      (recur (dec counter))))\n  @ant-counter)&quot; &quot;(def waypoints\n  (t/set-waypoints 40 20))&quot; &quot;(unique waypoints)&quot; &quot;(distinct waypoints)&quot; &quot;(count (distinct waypoints))&quot; &quot;(defn colony-tour\n  ;; Ant tours not being called in parallel --TO FIX\n  ;; Has N number of ants complete a full route and update the pheremone value\n  [ant-count colony]\n  (reset! ant-counter 0)\n  (loop [counter (dec ant-count)]\n    (ant colony)\n\n    (if (zero? counter)\n      (do\n        (reset! (:pher-map colony) (merge-with + (:evap colony) @(:pher-update colony) @(:pher-map colony)))\n        (reset! (:pher-update colony) (:pher-update-reset colony))\n        (println \&quot;Shortest path found: \&quot; (str (:path @(:best-route colony))))\n        (println \&quot;Path distance: \&quot; (str (t/get-route-distance (:path @(:best-route colony)) colony))))\n      (recur (dec counter))))\n  @ant-counter)&quot; &quot;(count waypoints)&quot; &quot;(def waypoints\n  (distinct (t/set-waypoints 40 20)))&quot; &quot;(def waypoints\n  (distinct (t/set-waypoints 40 3)))&quot; &quot;(def colony\n  (aco/create-colony waypoints 20 50 0.3))&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (let [path2  (conj (subvec path 1) (first path))\n        path-distances (reduce + (map #(t/get-distance %1 %2 (:waypoints colony)) path path2))]\n    (/ (:tour-coeff colony) (reduce + path-distances))))&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (let [path2  (conj (subvec path 1) (first path))\n        path-distances (reduce + (map #(t/get-distance %1 %2 (:waypoints colony)) path path2))]\n    (/ (:tour-coeff colony) path-distances)))&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  (println (str (map #(edge-weight active-node % colony) rem-nodes)))\n  ([active-node rem-nodes colony threshold-val]\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n         weight-denom (reduce + weight-num)\n         weight (mapv #(/ % weight-denom) weight-num)\n         weight-cnt (count weight)\n         threshold (loop [incremented-weight weight\n                          counter 1]\n                     (if (= weight-cnt counter)\n                       incremented-weight\n                       (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                              (inc counter))))\n         selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n     ;; (.println (System/out) (str threshold-val))\n     selected-threshold-index))\n  ([active-node rem-nodes colony]\n   (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(def colony\n  (aco/create-colony waypoints 10 25 0.3))&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n   (println (str (map #(edge-weight active-node % colony) rem-nodes)))\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n         weight-denom (reduce + weight-num)\n         weight (mapv #(/ % weight-denom) weight-num)\n         weight-cnt (count weight)\n         threshold (loop [incremented-weight weight\n                          counter 1]\n                     (if (= weight-cnt counter)\n                       incremented-weight\n                       (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                              (inc counter))))\n         selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n     ;; (.println (System/out) (str threshold-val))\n     selected-threshold-index))\n  ([active-node rem-nodes colony]\n   (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n         weight-denom (reduce + weight-num)\n         weight (do (println (str weight-denom))\n                    (mapv #(/ % weight-denom) weight-num))\n         weight-cnt (do (println \&quot;weight successful\&quot;)\n                        (count weight))\n         threshold (loop [incremented-weight weight\n                          counter 1]\n                     (if (= weight-cnt counter)\n                       incremented-weight\n                       (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                              (inc counter))))\n         selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n     ;; (.println (System/out) (str threshold-val))\n     selected-threshold-index))\n  ([active-node rem-nodes colony]\n   (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n         weight-denom (reduce + weight-num)\n         weight (do (println (str weight-denom))\n                    (mapv #(/ % weight-denom) weight-num))\n         weight-cnt (do (println \&quot;weight successful\&quot;)\n                        (count weight))\n         threshold (loop [incremented-weight weight\n                          counter 1]\n                     (if (= weight-cnt counter)\n                       incremented-weight\n                       (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                              (inc counter))))\n         selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n     ;; (.println (System/out) (str threshold-val))\n     selected-threshold-index)\n    (println \&quot;Finished\&quot;))\n  ([active-node rem-nodes colony]\n   (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(defn ant\n  ;; 1) Stores a closed loop route touching all waypoints\n  ;; 2) Generates the route score (Q/Dist)\n  ;; 3) Path-Offset shifts path indices by 1 (preparatory function for next step\n  ;; 4) Generates a map of all the node-edges selected\n  ;; 5) (evaluate-route) If this is the best global path, the global path/score is updated\n  ;; 6) Adds pheremone deposits for this tour\n  [colony]\n  (println \&quot;start\&quot;)\n  (let [path (make-path colony)\n        score (path-score path colony)\n        path-offset (conj (subvec path 1) (first path))\n        edges-to-update (map t/get-edge path path-offset)]\n\n    (t/evaluate-route path score (:best-route colony))\n    (dorun (map #(swap! (:pher-update colony) update-in [%] + score) edges-to-update))\n    (swap! ant-counter inc))\n  (println \&quot;finish\&quot;))&quot; &quot;waypoints&quot; &quot;(def euclidean-distance\n  (memoize\n    (fn [pt1 pt2]\n      (if (= pt1 pt2)\n        99999999999999999999999999999999999999\n        (math/sqrt (reduce + (map (comp #(math/expt % 2) -) pt1 pt2)))))))&quot; &quot;(defn get-distance\n  ;; Returns distance between 2 nodes in an array\n  [n1 n2 waypoints]\n  (let [nodeA (nth waypoints n1)\n        nodeB (nth waypoints n2)]\n    (euclidean-distance nodeA nodeB)))&quot; &quot;(fact \&quot;get-distance works for both lists and vectors\&quot;\n      (get-distance 0 1 mylist) =&gt; 5\n      (get-distance 0 1 myset)  =&gt; 5)&quot; &quot;(fact \&quot;The Euclidean distance calculation is working\&quot;\n      (def mylist '([0 0] [3 4] [5 12] [12 44]))\n      (get-distance 1 2 mylist) =&gt; 5\n      (get-distance 2 4 mylist) =&gt; 41\n      (get-distance 1 3 mylist) =&gt; 13)&quot; &quot;(fact \&quot;Exception thrown if selected node isn't in set\&quot;\n      (get-distance 1 8 '([0 0] [0 0] [1 1])) =&gt; (throws Exception))&quot; &quot;(fact \&quot;Ensure create-keys is working properly\&quot;\n  (create-keys 3) =&gt; [:01 :02 :12])&quot; &quot;(fact \&quot;The Euclidean distance calculation is working\&quot;\n      (def mylist '([0 0] [3 4] [5 12] [12 44]))\n      (get-distance 0 1 mylist) =&gt; 5\n      (get-distance 1 3 mylist) =&gt; 41\n      (get-distance 0 2 mylist) =&gt; 13)&quot; &quot;(fact \&quot;Ensure create-keys is working properly\&quot;\n  (create-keys 3) =&gt; [:01 :02 :12]\n  (create-keys 5) =&gt; [:01 :02 :03 :04 :12 :13 :14 :23 :24 :34])&quot; &quot;(swap! (:stored-history colony)\n       (conj @(:stored-history colony) {:tour 1 :distance 1 :path 1 :weight-vec 1}))&quot; &quot;(:stored-history colony)&quot; &quot;(swap! (:stored-history colony) (conj @(:stored-history colony) {:tour 1 :distance 1 :path 1 :weight-vec 1}))&quot; &quot;(conj @(:stored-history colony) {:tour 1 :dist 2})&quot; &quot;(swap! (:stored-history colony) conj {:tour 1 :distance 1 :path 1 :weight-vec 1})&quot; &quot;(def waypoints\n  (distinct (t/set-waypoints 50 200)))&quot; &quot;(def colony\n  ;; Variables\n  ;; List of waypoints\n  ;; Number of tours\n  ;; Number of ants\n  ;; Pheremone evaporation rate (&gt;1)\n  (aco/create-colony waypoints 5 15 0.80))&quot; &quot;(aco/execute colony)&quot; &quot;(defn create-colony\n  [waypoint-list tours ants evap-rate]\n  {:alpha-coeff 1\n   :beta-coeff 1.2\n   :tour-coeff 1\n   :waypoints (t/set-waypoints (count waypoint-list) 20)\n   :pher-map (atom (zipmap (t/create-keys (count waypoint-list)) (repeat 1)))\n   :pher-update (atom (zipmap (t/create-keys (count waypoint-list)) (repeat 0)))\n   :pher-reset (zipmap (t/create-keys (count waypoint-list)) (repeat 1))\n   :pher-update-reset (zipmap (t/create-keys (count waypoint-list)) (repeat 1))\n   :evap (zipmap (t/create-keys (count waypoint-list)) (repeat (- 1 evap-rate)))\n   :tour-count tours\n   :ant-count ants\n   :best-route (atom {:score 0 :path []})\n   :stored-history (atom [])\n   :local-optimal-core (atom 0)})&quot; &quot;@(:stored-history colony)&quot;], :remote []}}</component>
</project>