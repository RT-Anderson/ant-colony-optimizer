<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449331966855">{:repl-history {:ide [], :local [&quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (conj (str next-node-index) (str next-node)))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (apply (str next-node-index) (str next-node)))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (apply str next-node-index str next-node))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (apply str (next-node-index next-node)))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (apply str ((str next-node-index) (str next-node))))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (apply str (\&quot;aaaa \&quot; (next-node-index))))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (clojure.string/join (\&quot;SSS \&quot; \&quot;DD\&quot;)))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(clojure.string/join (\&quot;SSS \&quot; \&quot;DD\&quot;))&quot; &quot;(clojure.string/join [\&quot;SSS \&quot; \&quot;DD\&quot;])&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (clojure.string/join [\&quot;Index of next node: \&quot; (str next-node-index)]))\n          (.println (System/out) (str next-node))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (str (last nodes)))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (clojure.string/join [\&quot;Index of next node: \&quot; (str next-node-index)]))\n          (.println (System/out) (clojure.string/join [\&quot;Node value: \&quot; (str next-node)]))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (clojure.string/join [\&quot;Old Node: \&quot; (str (last nodes) )]))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (clojure.string/join [\&quot;Index of next node: \&quot; (str next-node-index)]))\n          (.println (System/out) (clojure.string/join [\&quot;Node value: \&quot; (str next-node)]))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (clojure.string/join [\&quot;Old Node: \&quot; (str nodes )]))\n      (.println (System/out) (str remaining-nodes))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (clojure.string/join [\&quot;Index of next node: \&quot; (str next-node-index)]))\n          (.println (System/out) (clojure.string/join [\&quot;Node value: \&quot; (str next-node)]))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (clojure.string/join [\&quot;Old Nodes: \&quot; (str nodes )]))\n      (.println (System/out) (clojure.string/join [\&quot;Remaining Nodes: \&quot; (str remaining-nodes )]))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (.println (System/out) (clojure.string/join [\&quot;Index of next node: \&quot; (str next-node-index)]))\n          (.println (System/out) (clojure.string/join [\&quot;Node value: \&quot; (str next-node)]))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(prob-weighting 0 [0] colony)&quot; &quot;(prob-weighting 0 [1] colony)&quot; &quot;(prob-weighting 0 [1 1 2] colony)&quot; &quot;(prob-weighting 0 [1 0 2] colony)&quot; &quot;(prob-weighting 0 [1 4 2] colony)&quot; &quot;(prob-weighting 0 [2 4 2] colony)&quot; &quot;(prob-weighting 0 [2 4] colony)&quot; &quot;(prob-weighting 0 [2 3] colony)&quot; &quot;(prob-weighting 0 [2 3 1] colony)&quot; &quot;(prob-weighting 0 [2 3 1 1] colony)&quot; &quot;(prob-weighting 0 [2 3 1 1 2] colony)&quot; &quot;(prob-weighting 0 [2 0 0 0] colony)&quot; &quot;(prob-weighting 0 [2 0 1 0] colony)&quot; &quot;(prob-weighting 0 [2 2 1 0] colony)&quot; &quot;(prob-weighting 0 [2 2 1 2] colony)&quot; &quot;(prob-weighting 2 [2 2 1 2] colony)&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n  (.println (System/out) (clojure.string/join [\&quot;Old Nodes: \&quot; (str active-node ) \&quot;New Nodes: \&quot; (str rem-nodes)]))\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n        weight-denom (reduce + weight-num)\n        weight (mapv #(/ % weight-denom) weight-num)\n        weight-cnt (count weight)\n        threshold (loop [incremented-weight weight\n                         counter 1]\n                    (if (= weight-cnt counter)\n                      incremented-weight\n                      (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                             (inc counter))))\n        selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n    ;;(.println (System/out) (str weight-num))\n    selected-threshold-index))\n  ([active-node rem-nodes colony]\n    (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n  (.println (System/out) (clojure.string/join [\&quot;Old Nodes: \&quot; (str active-node ) \&quot; New Nodes: \&quot; (str rem-nodes)]))\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n        weight-denom (reduce + weight-num)\n        weight (mapv #(/ % weight-denom) weight-num)\n        weight-cnt (count weight)\n        threshold (loop [incremented-weight weight\n                         counter 1]\n                    (if (= weight-cnt counter)\n                      incremented-weight\n                      (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                             (inc counter))))\n        selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n    ;;(.println (System/out) (str weight-num))\n    selected-threshold-index))\n  ([active-node rem-nodes colony]\n    (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(defn remove-vec-element\n  ;; Removes selected index from a vector\n  [node-array index]\n  (if (== 0 index)\n    (subvec node-array 1)\n    (into (subvec node-array 0 (dec index))\n          (subvec node-array index))))&quot; &quot;(remove-vec-element 0 [1 2 3])&quot; &quot;(defn remove-vec-element\n  ;; Removes selected index from a vector\n  [node-array index]\n  (if (= 0 index)\n    (subvec node-array 1)\n    (into (subvec node-array 0 (dec index))\n          (subvec node-array index))))&quot; &quot;(defn remove-vec-element\n  ;; Removes selected index from a vector\n  [node-array index]\n  (if (= 0 index)\n    (subvec node-array 1)\n    (into (subvec node-array 0 index)\n          (subvec node-array index))))&quot; &quot;(subvec [1 2 3] 0 1)&quot; &quot;(remove-vec-element [1 2 3] 0)&quot; &quot;(remove-vec-element [1 2 3] 1)&quot; &quot;(remove-vec-element [1 2 3] 2)&quot; &quot;(defn remove-vec-element\n  ;; Removes selected index from a vector\n  [node-array index]\n  (if (= 0 index)\n    (subvec node-array 1)\n    (into (subvec node-array 0 index)\n          (subvec node-array (inc index)))))&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (.println (System/out) \&quot;Pass cycle\&quot;)\n      (.println (System/out) (str open-nodes))\n      (.println (System/out) (clojure.string/join [\&quot;Old Nodes: \&quot; (str nodes )]))\n      (.println (System/out) (clojure.string/join [\&quot;Remaining Nodes: \&quot; (str remaining-nodes )]))\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          ;; (.println (System/out) (clojure.string/join [\&quot;Index of next node: \&quot; (str next-node-index)]))\n          ;; (.println (System/out) (clojure.string/join [\&quot;Node value: \&quot; (str next-node)]))\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n        weight-denom (reduce + weight-num)\n        weight (mapv #(/ % weight-denom) weight-num)\n        weight-cnt (count weight)\n        threshold (loop [incremented-weight weight\n                         counter 1]\n                    (if (= weight-cnt counter)\n                      incremented-weight\n                      (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                             (inc counter))))\n        selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n    ;;(.println (System/out) (str weight-num))\n    selected-threshold-index))\n  ([active-node rem-nodes colony]\n    (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(conj [(first open-nodes)] )&quot; &quot;(defn make-path\n  [colony]\n  (let [open-nodes (shuffle (range 0 (count (:waypoints colony))))]\n    (loop [nodes (conj [(first open-nodes)])\n           remaining-nodes (t/remove-vec-element open-nodes 0)]\n      (if (&gt;= 1 (count remaining-nodes))\n        (conj nodes (last remaining-nodes))\n\n        (let [next-node-index (prob-weighting (last nodes) remaining-nodes colony)\n              next-node (nth remaining-nodes next-node-index)]\n          (recur (conj nodes next-node) (t/remove-vec-element remaining-nodes next-node-index)))))))&quot; &quot;(make-path)&quot; &quot;(make-path colony)&quot; &quot;(mod 4 3)&quot; &quot;(mod 4 4)&quot; &quot;(map (t/get-distance % \n                (mod (inc %) (count %))\n                colony) nn)&quot; &quot;(map #(t/get-distance % \n                (mod (inc %) (count %))\n                colony) nn)&quot; &quot;(map #(t/get-distance % \n                (mod (inc %) 4)\n                colony) nn)&quot; &quot;(#(mod (inc %) 4) 1)&quot; &quot;(#(mod (inc %) 4) 4)&quot; &quot;(#(mod (inc %) 4) 3)&quot; &quot;(map #(t/get-distance % (mod (inc %) 4) colony) nn)&quot; &quot;(def nn\n  (make-path colony))&quot; &quot;nn&quot; &quot;(#(t/get-distance % (mod (inc %) 4) colony) (first nn))&quot; &quot;(t/get-distance 1 2 colony)&quot; &quot;(map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) nn)&quot; &quot;(reduce + (map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) nn))&quot; &quot;(def colony\n  {:alpha-coeff 1\n   :beta-coeff  1.5\n   :tour-coeff  1\n   :waypoints   '([160 6] [190 5] [2 2] [0 0])\n   :pher-map    {:01 1 :02 1 :03 1\n                 :12 1 :13 1\n                 :23 1}\n   :pher-update {:01 0 :02 0 :03 0\n                 :12 0 :13 0\n                 :23 0}\n   :tour-count  5\n   :ant-count   3})&quot; &quot;(defn ant\n  [colony]\n  (let [path (make-path colony)\n        score (path-score path colony)]))&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (/ (:tour-coeff)) (reduce + (map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) nn)))&quot; &quot;(ant)&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (/ (:tour-coeff colony)) (reduce + (map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) nn)))&quot; &quot;(repeat 5 ant)&quot; &quot;(dotimes 5 ant)&quot; &quot;(dotimes [5] ant)&quot; &quot;(prun 10 (.println (System/out) \&quot;Hello\&quot;))&quot; &quot;(pmap (.println (System/out) \&quot;Hello\&quot;) (range 4))&quot; &quot;(pmap ant [repeat 20 colony])&quot; &quot;(repeat 10 colony)&quot; &quot;(pmap ant '(colony colony))&quot; &quot;(def colony\n  {:alpha-coeff 1\n   :beta-coeff  1.5\n   :tour-coeff  1\n   :waypoints   '([16 6] [11 5] [12 5] [2 12])\n   :pher-map    {:01 1 :02 1 :03 1\n                 :12 1 :13 1\n                 :23 1}\n   :pher-update {:01 0 :02 0 :03 0\n                 :12 0 :13 0\n                 :23 0}\n   :tour-count  5\n   :ant-count   3})&quot; &quot;(pmap ant [colony colony colony])&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n         weight-denom (reduce + weight-num)\n         weight (mapv #(/ % weight-denom) weight-num)\n         weight-cnt (count weight)\n         threshold (loop [incremented-weight weight\n                          counter 1]\n                     (if (= weight-cnt counter)\n                       incremented-weight\n                       (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                              (inc counter))))\n         selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n     (.println (System/out) (str threshold-val))\n     selected-threshold-index))\n  ([active-node rem-nodes colony]\n   (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(pmap ant [colony colony])&quot; &quot;(pmap ant [colony colony colony colony])&quot; &quot;(map ant [colony colony colony colony])&quot; &quot;(defn prob-weighting\n  ;; Computes the probability threshold for the next node to be selected\n  ;; Note: this returns the index of the selected value in rem-nodes ; NOT the selected node\n  ([active-node rem-nodes colony threshold-val]\n   (let [weight-num (map #(edge-weight active-node % colony) rem-nodes)\n         weight-denom (reduce + weight-num)\n         weight (mapv #(/ % weight-denom) weight-num)\n         weight-cnt (count weight)\n         threshold (loop [incremented-weight weight\n                          counter 1]\n                     (if (= weight-cnt counter)\n                       incremented-weight\n                       (recur (#(assoc %2 %1 (+ (nth %2 (dec %1)) (nth %2 %1))) counter incremented-weight)\n                              (inc counter))))\n         selected-threshold-index (.indexOf threshold (first (filter #(&lt; threshold-val %) threshold)))]\n     ;; (.println (System/out) (str threshold-val))\n     selected-threshold-index))\n  ([active-node rem-nodes colony]\n   (prob-weighting active-node rem-nodes colony (rand))))&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (/ (:tour-coeff colony)) (reduce + (map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) path)))&quot; &quot;(map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) )&quot; &quot;(map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) [2 0 1 3])&quot; &quot;(reduce + (map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) [2 0 1 3]))&quot; &quot;(reduce + (map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) [1 2 3 0]))&quot; &quot;(reduce + (map #(t/get-distance %1 %2 (:waypoints colony)) [1 2 3 0] [1 1 2 3]))&quot; &quot;(subvec [1 2 3 4] 1)&quot; &quot;(conj [] (subvec [1 2 3 4] 1))&quot; &quot;(conj 1 (subvec [1 2 3 4] 1))&quot; &quot;(conj [1] (subvec [1 2 3 4] 1))&quot; &quot;(conj (subvec [1 2 3 4] 1) 1)&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (let [path2  (conj (subvec path 1) (first path))]\n  (/ (:tour-coeff colony)) (reduce + (map #(t/get-distance % (mod (inc %) 4) (:waypoints colony)) path))\n  ) )&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (let [path2  (conj (subvec path 1) (first path))]\n  (/ (:tour-coeff colony)) (reduce + (map #(t/get-distance %1 %2 (:waypoints colony)) path path2))\n  ) )&quot; &quot;(reduce + (map #(t/get-distance %1 %2 (:waypoints colony)) [1 2 3 0] [0 1 2 3]))&quot; &quot;(defn ant\n  [colony]\n  (let [path (make-path colony)\n        score (path-score path colony)]\n    path))&quot; &quot;(ant colony)&quot; &quot;(defn path-score\n  ;; Weighted score of route\n  [path colony]\n  (let [path2  (conj (subvec path 1) (first path))]\n  (/ (:tour-coeff colony) (reduce + (map #(t/get-distance %1 %2 (:waypoints colony)) path path2)))))&quot; &quot;(defn ant\n  [colony]\n  (let [path (make-path colony)\n        score (path-score path colony)]\n    score))&quot; &quot;(map ant [colony colony colony colony colony])&quot;], :remote []}}</component>
</project>